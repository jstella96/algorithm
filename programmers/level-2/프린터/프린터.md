# 프린터

## 문제 설명

프린터의 인쇄순서가 다음과 같을 때 내가 요청한 문서가 몇번째로 인쇄되는지 반환하는 솔루션을 작성하라

```
1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
3. 그렇지 않으면 J를 인쇄합니다.
```

## 첫번째 문제 풀이

### 풀이방법

기본적인 프린터의 인쇄는 first in, first out 을 따르므로 Queue를 사용해준다.
처리할 부분은 Queue의 가장 상단에 있는 값의 priority 보다 더 높은 priority이 Queue안에 존재한다면 상단의 값을 다시 queue의 뒤에 넣어준다.

### 자바 풀이

```java
import java.util.*;

class Document{
	int id;
	int priority;
	public Document(int id, int priority){
		this.id=id;
		this.priority=priority;
	}
}

class Solution {
    public int solution(int[] priorities, int location) {
        int answer=0;
		Queue<Document> Q = new LinkedList<>();
		for(int i=0; i<priorities.length; i++){
			Q.offer(new Document(i,  priorities[i]));
		}
		while(!Q.isEmpty()){
			Document tmp = Q.poll();
			for(Document x : Q){
				if(x.priority > tmp.priority){
					Q.offer(tmp);
					tmp=null;
					break;
				}
			}
			if(tmp!=null){
				answer++;
				if(tmp.id == location) return answer;
			}
		}
		return answer;
    }
}

```

### 시간복잡도

시간복잡도는 O(N^2)으로 높은편이나
대기목록이 1개 이상 100개 이하의 문서라고 제한 되어있으므로 n^2을 실행하여도 큰 성능 문제를 일으키지 않는다.

## 두 번째 풀이

### 풀이방법

다른 이들의 풀이를 보니 location을 이용하는 풀이법도 있다.
priority가 아닌 location을 저장하여 정렬 후
