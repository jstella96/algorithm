# 디스크 컨트롤러

## 문제 설명

각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 해라 (단, 소수점 이하의 수는 버립니다)

## 문제 풀이

(E(A)+E(B)+E(C)) -(S(A)+ S(B)+S(C)) 값이 작아야 평균이 작아 질 수 가 있다. 즉, 현재 실행중인 작업이 끝나는 시점에 소요시간이 가장 작은 것 부터 실행한다. 그러하면 EndTime이 가장 작은 것을 선택할 수 있다.

1. startTime 기준으로 배열을 정렬 한다
2. 각 작업이 처리 될 때 마다 count를 +1 해주며 모든 작업이 끝날때까지 반복문을 순회한다.
3. 반복문안에서 한 작업이 끝날때 그 끝 시점 보다 시작시점이 앞인 작업을 소요시간 기준으로 오름차순 정렬된 PriorityQueue에 넣는다.
4. 다음작업은 PriorityQueue에 가장 앞에 있는 작업이 된다. 그 작업을 선택했을 때 EndTime이 가장 작기 때문이다.
5. 큐가 비어있다면 대기요청이 없다는 것. 작업 완료 이후에 다시 요청이 들어온다는 의미

## 풀이 코드

```java
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {

	public int solution(int[][] jobs) {

		int sumWorkTime = 0;
		int currentTime = 0;
		int jobsIdx = 0;
		int count = 0;

		Arrays.sort(jobs, (o1, o2) -> o1[0] - o2[0]);

		PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) ->  o1[1] - o2[1]);

		while (count < jobs.length) {
			//한 작업이 끝날때까지 새로 들어온 요청이 없을 때
			if (pq.isEmpty()) {
				currentTime = jobs[jobsIdx][0];
			//한 작업이 끝날때 새로 들어온 요청이 있을 때 가장 짧은 요청부터 수행
			} else {
				int[] temp = pq.poll();
				sumWorkTime += temp[1] + currentTime - temp[0];// (소요시간 + 현재까지 시간 - 요청한시간)
				currentTime += temp[1];
				count++;
			}
			//현재 진행 중인 작업의 끝나는 시점전에 들어온 요청을 PriorityQueue에 넣는다.
			while (jobsIdx < jobs.length && jobs[jobsIdx][0] <= currentTime) {
				pq.add(jobs[jobsIdx]);
				jobsIdx++;
			}
		}

		return (int) Math.floor(sumWorkTime / jobs.length);
	}
}
```
