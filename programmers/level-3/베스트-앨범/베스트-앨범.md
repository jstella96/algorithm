## 디스크 컨트롤러

## 문제 설명

## 문제 풀이

여기서 포인트는 map 안에 자료구조를 넣는것! 객체가 될수도 있고 array,map,queue,set
등등..
map을 두개 만든다.
하나는 각 장르별 카운트를 세는 map,
다른 하나는 각 장르별 곡을 담아놓은 PriorityQueue
PriorityQueue 의 정렬 기준을 각 곡의 재생 횟수 되도록 한후
장르별 카운트를 세는 map 또 한 총재생횟수를 정렬 기준이 되도록한다.
위의 값들을 나열하면 구하고자 하는 값들의 순서가 나온다.

## 보완전

시간단축..

## 자바 코드

```java
import java.util.*;

class Solution {


    public int[] solution(String[] genres, int[] plays) {

        HashMap<String, Integer> cntMap = new HashMap<>();
        HashMap<String, PriorityQueue > musicMap = new HashMap<>();


        for(int i = 0 ; i < plays.length ; i++  ){
            cntMap.put( genres[i] , cntMap.getOrDefault( genres[i] ,0) + plays[i] );
            if(!musicMap.containsKey(genres[i])){
                PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) ->  o2[1] - o1[1] ); //내림차순
                musicMap.put(genres[i],pq);
            }
            int[] arr = new int[] {i,plays[i]};
            musicMap.get(genres[i]).add(arr);
        };

         //**코드 단축! 좋은 방법인듯!
         List<String> sortList = new ArrayList<>(cntMap.keySet());
			 	 Collections.sort(sortList, (o1, o2) ->  cntMap.get(o2) - cntMap.get(o1));


        List<Integer> answerList = new ArrayList<>();
        for(String str : sortList ){
            int count  = 0;
            PriorityQueue<int[]> musicPq = musicMap.get(str);
            while(!musicPq.isEmpty() && count < 2){
                count++;
                int[] arr = musicPq.poll();
                answerList.add(arr[0]);
            }
        }

        int [] answer = new int[answerList.size()];
			 	for( int i =0;i<answerList.size();i++) {
			 		answer[i] = answerList.get(i);
			 	}
        return answer;
    }

}
```
