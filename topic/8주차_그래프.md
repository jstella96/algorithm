1. https://leetcode.com/problems/evaluate-division/

"a"/"b" : 3
a = b \* 3
그래프
c->(2)->b()->
map을
a : b,3
b : c,3

이런식으로 해서 연결될수있으면 구할수있다,.

- 주의
  역수, 미리 그래프 역으로 만들거나
  구할때 역수도 구해 보거나

https://leetcode.com/problems/network-delay-time/
다익스트라로  
모든 노드의 최단거리 거하고 그중 최대값을 구한다.
https://leetcode.com/problems/course-schedule-ii/

dfs를 돌면서 starttime, endtime 을 만들고 endtime 기준으로 정렬
상관없는것도, endtime 기준으로 큰순,
()[]
https://leetcode.com/problems/course-schedule/

https://leetcode.com/problems/word-break/

1. [ㄷㄷㄷ](https://leetcode.com/problems/evaluate-division/)
2. [ㄷㄷㄷ]

3. [코스 스케줄1](https://leetcode.com/problems/course-schedule/)
   **풀이 방법**
   선수관계 판별한다. true,false 만 체크함으로 visited와 finish 만 체크한다.
   노드가 호출 되면 visited, 후수 과목이 다 호출되고 끝나면 finish 체크
   더 자세한 건 아래 '코스 스케줄2' 풀이 참고
   **사이클 판별법**
   [조건]
   visited 는 1이고 finish 0 인거

4. [코스 스케줄2](https://leetcode.com/problems/course-schedule-ii/)
   **풀이 방법**
   [topological 알고리즘]
   노드를 돌아다니면서 startTime과 endTime을 기록한다.
   한노드를 무작위로 선택 후 후수 과목 호출 호출된 노드는 startTime을 기록 그리고 아래 모든 후수 과목 노드들을 돌았을 때 endTime을 적고 상위 노드로 이동. 모든 노드들을 돌면서 그래프에 값을 준다.
   그 후 endTime이 크다는 것은 1)선수과목이거나 2)관련이 없다는 것을 의미하므로
   endTime이 큰 것 부터 한다는 것은 후수과목을 먼저할 일이 없다. 사이클없는것만 가능
   (참고)노드가 x노드, y노드 두개 있을때 y노드의 endTime 이 더 크다면 무엇이 선수 과목일까? y이다. 아니면 관련이 없을 수 도 있다.

   **사이클 판별법**
   [조건]

   1. start 타임이 이미 있고 endTime 안 적혀있는 노드를 호출 했을 때(후수과목이라 생각하고 호출)
   2. start 타임이 있는 노드에 endTime 안적혔다는 것은 이후에 호출되는 애들이 다 해당노드보다 후수과목이란건데, 근데 해당노드를 불렀으니까 이건 사이클이 된다.

5. [유명인을 찾아라](https://leetcode.com/problems/find-the-celebrity/)
   [풀이]

   - n^2 : 일반적인 풀이 브루트 포스
   - n^2 > x > n : 일반적인 그래프 서치 카눈트
   - 2n : 문제 특화.
     한번 물어 볼 때 마다 한명씩 지울 수 있다. 만약 물어 본 사람을 아는 경우는 물어본 해당 노드를 삭제하고, 모른다 하면 모른다 한 그 노드를 삭제한다. 그럼 n만에 셀럽 후보 한명이 나온다. (본인이 아는 사람을 없는 애를 찾는다.) 이 때 본인이 아무도 모르는 애는 한명은 있어햐 한다. 만약 2명이 존재한다면 그 집단은 셀럽이 없다. 둘 다 서로 모른다.
     그럼 그때 이 사람이 셀럽이 아닌 예외 케이스를 위해서 모두가 모두가 그를 아는지 검증한다. 이때 n이 필요하다.

6. [word-break](https://leetcode.com/problems/word-break/)
   [문제설명]
   Str과 word가 주어지는데 해당 word를 조합해서 str을 만들 수 있는가?
   [풀이]
   map 안에 key로 각 알파벳을 value에 list에 각 단어를 넣는다.
   그 후 해당 str의 시작부분 알파벳에 해당하는 list를 돌려준다.
   그단어만큼 앞을 자른 후 str이 다 사라질 때 까지 해당과정을 반복한다. 하나의 루트라도 true가 나오면 된다.
   [또 다른 풀이]
   메모리제이션을 해서 , String 을 자르면서 간다 n^2
   [주의점]
   subSting은 O(1)이 아니다.
