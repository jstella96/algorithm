1. [https://programmers.co.kr/learn/courses/30/lessons/42626](https://programmers.co.kr/learn/courses/30/lessons/42626)
   전형적인 P.queue 문제

   - 우선순위 큐를 써야 할 때

   * 가장 낮은 것을 뽑고,
   * 새로운 값이 정렬되서 들어가야될때
     insert 에 O(n)
     put O(1)

2. [프로그래머스/디스크 컨트롤러](https://programmers.co.kr/learn/courses/30/lessons/42627)

   현재 작업중인게 없으면 가장 요청시간이 빠른것 을 처리한다는 룰이 있어서 마냥 끝나는 시간이 짧은 것을 고를 수 는 없다.
   예외 케이스 한 작업이 끝난 순간 새로 시작할 수 있는 작업이 없을 때 다음작업

```java
/*
  1. 작업 큐랑 대기큐를 둔다.
  2. 대기큐는 시작시간 기준으로 정렬 작업큐는 소요시간 기준으로 정렬한다.
  3. 모든 작업은 대기 큐에 들어가 있고 특정 시점에 작업가능한 작업들은 작업큐로 넣어준다.
*/
  while(작업가능큐랑 대기큐가 비어있지 않을 때){
    if(작업가능 큐에 작업이 있는가?){
      job = 작업가능큐.poll()
      time += job.소요시간
      total += time - job.시작시간 //진짜대기시간 //위랑 같은 객체임
    }else{
      time = 대기큐.peek().시작시간;
    }
    while(대기큐.peek().시작시간 <= time){
        작업가능큐.offer( 대기큐.pop() );
      }
  }

```

3. [https://leetcode.com/problems/find-median-from-data-stream/](https://leetcode.com/problems/find-median-from-data-stream/)

1. min max 힙 2개
1. 바이너리서치

팔로우업: 1-100까지 테이블을 만든다.
99%라 앞뒤 count 만 하면 된다. 51% 이상에서 효과를 보임


4. [https://leetcode.com/problems/employee-free-time/](https://leetcode.com/problems/employee-free-time/)

- [x] 리트코드/
      정렬하고 시작할 때 +1 -1 / 해서
      디스크 컨트롤러 처럼 풀 되, 작업큐를 없애고 끝내는 시간을 업데이트 해도 된다.

5. [https://leetcode.com/problems/delete-and-earn/](https://leetcode.com/problems/delete-and-earn/)

   - [x] 리트코드 / Delete and Earn -별

   1. 각 숫자가 나온 횟수를 hash테이블로 만든다
      (키 : 숫자 value: 횟수)
      함수를 DFS로 표현한다면
      노드를 f(n) : n 이후로 구하는 값의 최대
      f(1) -먹는다>f(3) -안먹는다->f(2)
      먹다-> f(4)
      안먹다-> f(3)

6. [https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)
   - [x] 리트코드 / Remove All Adjacent Duplicates in String II — 별

stack에 [알파벳,연계카운팅]으로 만든다.
