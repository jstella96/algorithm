# 선형자료구조

### 스택 큐

스택 : LIFO(Last In First Out) 후입선출

큐 : FIFO (First IN First Out) 선입선출

### 해시테이블

해시테이블 또는 해시 맵은 키를 값에 매핑 할 수 있는구죠인 연관 배열 추상자료형을 구현하는 자료구조 이다. 

- 대부분의 연산이 O(1)

### 해시란?

해시함수란 임의크기의 데이터를 고정 크기 값으로 매핑하는 게 사용할수있는 함수를 말한다

- 해시테이블의 핵심은 해시 함수다.  dasdasd⇒ds
- 해시테이블을 인덱싱하는 하기위해 해시함수사용하는것을 해싱이라고한다.
- 해싱은 정보를 가능한 빠르게 저장하고 검색하기위해 사용하는 중요한 기법
- 최적의 검색이 필요한 분야에 사용된다.

### 로드팩터

- 해시테이블에 저장된 데이터 개수 n을 버킷의 갯수 k로 나눈값으로
- 비율에따라 해시함수를 재작성해야될지나 해시테이블 크기를 조정할지를 결정한다.
- 자바 10의 경우 0.75이 넘어가면 해시테이블 공간 재할당한다.

### 해싱

- 개별체이닝 : 충돌발생시 연결리스트로 연걸하는 방식
- 오픈어드레싱  : 충돌발생시 빈공간 찾아나서는 방식
- 자바,c,go : 개별체이닝
- 루비,파이썬: 오픈어드레싱

# 비선형 자료구조

데이터 요소가 순차적으로 선형으로 배열되지 않는 자료구조를 비선형 자료구조 라고 한다. 탐색이 복잡하고 선형에 비해 구현하기도 다소 번잡하지만 메모리를 좀 더 효율적으로 사용ㅇ 할 수 있다는 장점이 있다. 대표저ㅗㄱ으로 그래프를 예로 들 수 있다 ,

그래프란 객체의 일부 쌍 pair 들이 ‘연관되어’ 있는 객체 집합구조 를 말 한다 . 

오일러 경로 : 모든 간선을 한번씩 방문하는 유한그래프 

- 모든 정점이 짝수 개의 차수를 갖는 다면 성립

해밀턴 경로 : 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로 

- 최적알고리즘 이없는 대표적인  NP-complete(완전) 문제
- 다시 출발점으로 돌아오는 경로 해밀턴 순환이라고 부른다.

둘 차이 간선이냐 , 정점이냐 

## 그래프 순회 :

- 그래프 탐색이라고도 불리며 그 그래프의 정점을 방문 하는 과정
- 깊이우선탐색 DFS(Depth First Serch)와 너비우선탐색 BFS(Breadth-Firrst-Serch)이 있다.
- DFS
    - 스택이나 재귀로 구현한다.
    - 백트레킹을 통해 뛰어냔 효용 보인다
- BFS
    - 주로 큐로 구현한다.
    - 그래프의 최단경로를 구하는 문제 등에 사용 된다 .
    - 재귀로 동작하지 않는다.
- 백트레킹
    - 해결책에 대한 후보를 구축해 나가아가 가능성이 없다고 판단되는 즉시 후보를 포기(백트레킹) 해 정답을 찾아가는 법용적인 알고리즘으로 제약충족문제에 특히 유용하다.
    - DFS 는 백트레킹의 골격을 이룬다. 주로 재귀로 구현한다.
    - 가보고 되돌아오고를 반복 최악의 경우는 모든 경우를 다 거친다음에 도착할 수 있다. 자 칫 브루트 포스와 유사하지만 한번 방문 후 가능성 없는 경우 즉시 후보를 포기한다는 점에서 매번 같은 경로 ㅏㅇ문하는 브루트 포스 보다는 우아하다.
    - 트리 가지치기 한다고 함
- 제약 충족 문제
    - 제약 충족 문제란 수많은 제약조건을 충족하는 상태를 찾아내는 수학문제이다
    - 백트ㄹ킹은 제약충족문제를 풀이하는데 필수적이다. 가지치기를 통해 제약 충족 문제를 최적화 하기 때문이다.

### 최단 경로문제

- 최단 경로문제
    - 최단경로문제는 각 간선이 가중치 합이 최소가 되는 두정점 (또는 노드) 사이의 경로를 찾는 문제이다. 지도상 한지점에서 다른지점으로 갈때 가장장 빠른길을 찾는것과 비슷한 문제

## 트리

- 재귀로 정의된 자기 참조 자료구조, 부모-자식관계의 서브트리로 구성되며 서로 연결된 노드의 집합

## 힙

- 힙의 특성(최소 힙 에서는 부모가 항상 자식보다 작거나 같다)를 만족하는 거늬 완전한 트리인 특수한 트리기반의 자료구조 이다.
- 힙은 정렬된 자료구조가 아니다, 부모노드가 항상 자식보다 작다는 조건만 만족할 뿐이다.  부모-자식간의 관계만 정렬하고 좌-우 간의 관계는 정렬되어있지 않다.

## 트라이

- 검색 트리의 일종으로 일반적으로 키가 문자열인 동적 배열 또는 연관 배열을 저장하는데 사용되는 정렬된 자료구조다.
- 자연어 처리 분야에서 문자열 탐색을 위한 자료구조로 널리쓰인다.
- 각각의 문자단위로 색인을 구축한 것과 비슷한데,  단어 apple을 찾는 다면 5번 만에 문자열의 존재여부 파악가능

# 알고리즘

## 정렬

정렬알고리즘은 목록의 요소를 특정 순서대로 넣는 알고리즘이다. 대개 숫자식 순서(NumricalOrder)와 사전식 순서(Lexicaographical Order)로 정렬한다. 

### 버블 정렬

- 효율적이지 못한 알고리즘
- 시간복잡도 항상O(n^2)

```jsx
//수도 코드 
BoobleSort(A)
	for i from 1 to A.length
		for j from 0 to A.length -1 
			if A[j] > A[j+1]
				swap A[j] with A[j+1]
```

## 병합정렬(Marge Sort)

- 분할정복(Divide and Conquer) 알고리즘
    - 분할정복이란 : 주어진 문제를 여러 sub 문제들로 나눈 다음 그 문제들을 해결 한 후 합쳐서 답을 내는 것
- 최선과 최악 O(nlogn) 의 시간복잡도를 가진다
- 대부분 퀵 정렬보다는 느리지만 일정한 실행속도와 안정정렬(Stable Sort)라는 점에서 많이 쓰인다.

```jsx
//수도코드 //사진도 넣음 좋을 듯 
```

## 퀵정렬(Quick Sort)

- 피벗을 기준으로 좌우를 나누는 특징으로 파티션 교환 정렬이라고도 불린다.
- 분할 정복 알고리즘이다
- 매우 빠르며 굉장히 효율적이지만 O(nlogn), 최악의 경우(=이미 정렬된 배열이 입력값으로 들어왔을 경우 ) O(n^2)의 시간복잡도를 갖는다.
- 대부분 병합정렬보다 빠르지만  입력값에 따라 성능차이가 큰편, 개선하는 연구 결과도 많이 나옴
- 피벗이란 개념을 통해 피벗보다 작으면 왼쪽, 크면 오른쪽 같은 방식으로 파티셔닝 하면서 쪼개 나간다.

```jsx
//수도코드, 로무토 파티션 계획: 항상 맨 오른쪽의 피벗을 택하는 단순한 방식
QuickSort(A, lo, hi)
	if lo < hi then
		pivot := partition(A, lo, hi)
		QuickSort(A, lo, pivot - 1)
		QuickSort(A, pivot + 1, hi)
```

- 위 수도코드는 퀵정렬의 메인함수이다. 파티션을 나누고 각각 재귀 호출하는 전형적인 분할정복 구조이다.

```jsx
//수도코드, 로무토 파티션 계획: 항상 맨 오른쪽의 피벗을 택하는 단순한 방식
partition(A, lo, hi)
	pivot := A[hi]
	i := lo 
	for j := lo to hi do
		if A[j] < pivot then
			swap A[i] with A[j]
			i := i+1
	swap A[i] with A[hi]
	return i 
```

- 피벗은 맨 오른쪽 값을 기준으로 한다.  2개의 포인터가 이동해서 오른쪽 포인터의 값이 피벗보다 작다면 서로 스왑한다.
- 마지막에 왼쪽 포인터 위치로 피벗이 이동하면서 피봇의 값 왼쪽에는 작은값 큰쪽에는 큰값이 모여있게 된다.
- 위와 같은 방법으로 분할하며 정복을 진행하여 lo > hi 가 될 떄 까지 재귀로 반복하면 정렬이 완료 된다.

## 안정 정렬 vs 불안정 정렬

안정정렬 : 중복된 값을 입력 순서와 동일하게 정렬한다.

- 기존의 정렬했던 순서는 다른 기준으로 재정렬하더라도 기준순서가 유지된 상태에서 정렬이 이루어지는 것
- 불안정 정렬은 재정렬하면 기존의 정렬 순서는 무시된 채 뒤섞임
- 병합정렬, 버블정렬은 안정정렬 , 퀵정렬은 불안정 정렬이다.

### 팀소트(TIm Sort)

- ‘실제 데이터는 대부분 이미 정렬되어 있을 것이다’ 라고 가정하고 실제 데이터에서 고성능을 낼 수 있도록 설계한 알고리즘
- 병합정렬과 삽입정렬을 휴리스틱하게 조합한 알고리즘
- 최선 시간복잡도 O(n) 평균,최악 시간복잡도 O(nlogn)
- 이론적으로 어떠한 정렬 알고리즘도 한번이상 비교하게 되면 O(nlogn) 보다 빨라질 수 없지만 팀소트는 이미 정렬 되어 있는 경우 비교를 건너뛰기 때문이 O(n)까지 가능하다
- 현업에서 가장 널리쓰이는 알고리즘

## 이진 검색(Binary Seasrch)

- 정렬된 배열에서 타겟을 찾아내는 검색 알고리즘
- 값을 찾아내는 시간 복잡도 O(logn)
- BST → 저장된 구조를 저장하고 탐색하는 **자료구조** BS → 정렬된 배열에서 값을 찾아내는 **알고리즘**
- 중간값부터 탐색 시작 크다면 왼쪽포인터 오른쪽으로 이동 작다면 오른쪽포인트를 왼쪽으로 이동 다시 양쪽 포인트의 중간값 탐색

```jsx
//수도코드 

```

## 슬라이딩 윈도우& 투 포인터

### 투포인터

- 대개는 시작점과 끝점 또는 왼쪽 포인터와 오른쪽 포인터 두 지점을 기준으로 하는 문제 풀이 전략을 뜻한다. 범위를 좁혀 나가기 위해서는 일반적으로 배열이 정렬되어 있을 때 좀 더 유리하다.
- 책에 등장하는 내용이 아닌 알고리즘 풀이와 관련한 실전적인 풀이 기법

### 슬라이딩 윈도우

- 고정사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘
- 2개의 네트워크  호스트간의 패킷 흐름을 제어하기 위한 방법을 지칭하는 네트워크 용어
- 투포인터가 주로 정렬된 배열을 대상으로 한다면 슬라이딩 윈도우는 정렬 여부에 관계없이 활용된다.
- 투포인터 : 정렬 대부분 o  , 윈도우 사이즈 가변,  이동 좌우 포인터 양방향
    
    슬라이딩 윈도우 : 정렬 여부 관련 x, 윈도우 사이즈 불변, 이동 : 좌 또는 우 방향
    

 

## 그리디 알고리즘(Greedy Algorithm)

- 글로벌 최적을  찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘 이다.
- 알고리즘 최적화 문제를 대상으로 한다.
- 최적해를 찾을 수 있으면 그것을 목표로 삼고 찾기 어렵다면 주어진 시간내에 그런대로 괜찮은 해를 찾느 것을 목표로 삼는다.
- 그리디 알고리즘이 잘 작동한는 문제들은 아래와 같은 특징을 가진다.
    - 탐욕선택속성(Greedy Choice Property)  : 앞의 선택이 이후 선택에 영향을 주지 않는다.
    - 최적부분구조(Optimal Subtructure):  최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우
- 다익스트라 알고리즘, 허프만 코딩 알고리즘(허프만 트리 빌드시), 머신러닝 빌드시 의사결정 트리 알고리즘(ID3) 등 에 활용된다
- DP 와 그리디 둘다 최적 부분 구조 문제를 푼다는 점에서 공통점이 있다. 차이는 아래와 같다
- DP : 하위 문제에 대한 최적의 솔루션 찾은 다음 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션에 대한 선택을 한다.
- 그리디알고리즘 : 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를  더 작게 줄여 나간다.

### ### 여긴 문제예시 필요함!

## 분할정복

다중 분기 재귀를 기반으로 하는 알고리즘 디자인 패러다임을 말한다 

- 직접 해결할 수 있을 정도로 간단한 문제가 될때까지 문제를 재귀적으로 쪼개나간 다음 그 하위 문제의 결과들을 조합하여 원래 문제의 결과로 만들어 낸다.
- 재귀를 활용하는 대표적인 알고리즘
- 대표 : 병합정렬
    
    

```jsx
// 수도코드 
funtion F(x)
	if F(x) 작은 단위 then: 
		--- 정복 
	
 else:
		x를 x1 , x2로 분할 
		F(x1)과 F(x2)를 호출 
		return F(x1) + F(x2) 로 F(x)를 구한 값 
			-- 조합 , 분할
```

- 분할 :  문제를 동일한 유형의 여러 하위 문제로 나눈다
- 정복 : 가장 작은 단위의 하위 문제를 해결하여 정복한다
- 조합 :   하위 문제에 대한결과를 원래 문제에 대한 결과로 조합한다.

## 다이나믹 프로그래밍 알고리즘

- 정의 : 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고라즘이다.
- 다이나믹 프로그래밍 알고리즘을 이용하면, 최적 부분 구조 를 갖고 있는 문제를 풀이 할 수 있다.
    - 최적부분 구조 : 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 문제
- 그리디 알고리즘은 항 상 그순간에 최적이라고 생각되는 것들을 선택하면서 풀이해 나가는 것 , 다이나믹 프로그래밍은 중복된 하위문제들의 결과를 저장해놨다가 풀이해나간다는 차이가 있다.

다이나믹 프로그래밍 ⇒ 최적 부분 구조 , 중복된 하위 문제들
그리디 알고리즘  ⇒  최적 부분 구조 탐욕선택속성
분할정복  ⇒  최적부분 구조

### 다이나믹 프로그래밍 방법론

- 하향식접근법 : 메모이제이션; 하위문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어 나간다.
- 상향식 접근법 : 타뷸레이션 , 작은 하위문제부터 살펴본 다음 큰 문제의 정답을 풀어나간다.