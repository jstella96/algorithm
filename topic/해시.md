1.  [전화번호목록](https://programmers.co.kr/learn/courses/30/lessons/42577)

    - 해시로 전화번호 다 넣고
    - 전화번호를 각각 하나씩 자르면서 set 안에있는지 확인한다.
    - 길이 제한이 있어서 시간복잡도 안크다

2.  [ 위장](https://programmers.co.kr/learn/courses/30/lessons/42578)

    프로그래머스/ 위장
    조합 : (A+1)(B+1) -1 // A+1 이유는 안입은경우 / -1 이유는 아예아무것도 안입을수 없어서

    - 위장 옷장 테이블을 만들기 위해 해시맵을 사용한다

    어려울 경우

    - value에 list 들어가있을때
    - 옷갯수 정해져있을 때 상위는 3개 하위는 2개 3C5 \* 2C5 .. 가되니까
      지금은 1C5 -> 1C6(안입은경우)

3.  [https://leetcode.com/problems/subarray-sum-equals-k/](https://leetcode.com/problems/subarray-sum-equals-k/)

    리트코드/ subarray-sum-equals → 별

    0을 포함한 양의 정수만 있을 때는 투포인터를 이용해서 O(n)만에 해결 할 수 있다 왼쪽포인터가 가르키는 배열의 인덱스를 머리로 하는 subarray가 k값을 넘냐가 기준

    subArray
    A: 2 3 2 5
    SS : 2 5 6 11
    subarrysum : ss[i] - ss[j] (맨앞에 0 넣기 )
    i-j까지 합을 바로 구할 수 있다.
    이래도

    풀이과정
    ss값을 키로가진 해시맵을 만든다.
    value 는 index를 가진 list 이다.

    그후 ss 를 순회하면서 해당 인덱스가 k를 가지기 위해 필요한 값을 테이블에서 빼서
    해당 리스트에서 현재 인덱스 보다 큰 인덱스 갯수 찾는다. (size - index)

    - 만약 최대 차이를 구하는 값이였다면
      - min/max 변수로

4.  [https://leetcode.com/problems/verifying-an-alien-dictionary/](https://leetcode.com/problems/verifying-an-alien-dictionary/)

    리트코드/ verifying-an-alien-dictionary

    - order을 map에 넣어서 value 값은 숫자 -> 검색시 시간 줄이려고
    - 왜 인접 단어만 비교하고 첫벗째 마지막은 비교 안하는가? 앞에서부터 비교하ㅕㄴ서 왔기 떼문에 첫번쩨께 마지막 보다 크다는건 성립된다.

5.  [https://leetcode.com/problems/daily-temperatures/](https://leetcode.com/problems/daily-temperatures/)
    리트코드/ daily-temperatures

    스택에 온도와 index를 같이 넣어 논다.

    - 스택을 보고 맨위보다 온도가 높으면 스택 값을 빼면서 해당 index 값 업데이트 시켜주고

    - 스택에 값 넣는 조건 : 스택의 맨위값보다 작은걸 넣는다. 큰것들은 해당되니까 다 pop 시키고 답 적었다.

    스택안도 질서가 있다 밑에가 가장 온도가 높다 가장 밑> 두번째 밑> 세번째 밑>... 이 질서 가 있기 때문에 스택의 맨 위만 봐도 된다.
    앨리먼트간의 질서유지

6.  [https://leetcode.com/problems/flatten-nested-list-iterator/](https://leetcode.com/problems/flatten-nested-list-iterator/)

    리트코드/ flatten-nested-list-iterator → 별

이터레이터를 돌면서
숫자를 만나면 바로 queue 에 넣고 리스트를 만나면 다시 재귀함수를 해당 배열에 돌린다.
