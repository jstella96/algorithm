바이너리 서치 검색은 시간 복잡도 깊이이다, log2K =>. O(logN)
바이너리서치는 무조건 아래쭉쭉 붙는다. 라트노드 안바뀐다.
->그래서 레드-블랙트리 쓴다.

1. [https://leetcode.com/problems/time-based-key-value-store/](https://leetcode.com/problems/time-based-key-value-store/)
   - snapshot isolation
   - map 에 리스트(timestop. 값)를 넣는다.
   - 바이너리서치
2. [https://leetcode.com/problems/maximum-profit-in-job-scheduling/](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)
   - [ ] 리트코드/Maximum Profit in Job Scheduling
   - 1. end 기준으로 정렬 하고 앞선ㅁ 값
   - 2. dfs에
3. [https://leetcode.com/problems/random-pick-with-weight/](https://leetcode.com/problems/random-pick-with-weight/)

   - [ ]

   - 가중치 경계..
   - random 함수를 사용해서. !!

4. [https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/](https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)

   - [ ] 리트코드/ convert-binary-search-tree-to-sorted-doubly-linked-list

5. [https://leetcode.com/problems/delete-node-in-a-bst/](https://leetcode.com/problems/delete-node-in-a-bst/)
   - [ ] 리트코드/ Delete Node in a BST
6. [https://leetcode.com/problems/balance-a-binary-search-tree/](https://leetcode.com/problems/balance-a-binary-search-tree/)
   - [ ] 리트코드 / Balance a Binary Search Tree
